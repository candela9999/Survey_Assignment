---
title: "Survey II Assignment"
output: html_document
date: "2025-02-13"
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Loading libraries

```{r}
rm(list = ls())
library(tidyverse)
library(haven)
library(readxl)
library(xml2)
library(rvest)
library(janitor)
library(DataExplorer)
library(countrycode)
```

# Loading data

## Survey data

```{r}
data_raw <- read_dta("ZA7575.dta")
```

## Country-level data

### GDP per capita

Retrieved from Eurostat (<https://ec.europa.eu/eurostat/databrowser/view/tipsna40/default/table?lang=en>) for the year 2019.

```{r}
gdp_data <- read_xlsx("gdp_pc_2019.xlsx", sheet = 3, range = "A11:B39", col_names = c("country", "gdp_pc"))
str(gdp_data)
```

1)  United Kingdom is missing from this dataset as well as from a few others in Eurostat (we might have to find it somewhere else).

2)  Data needs further cleaning

3)  Reflect whether we might be better suited with other measures of GDP (GDP at PPP)

### Rural population

Retrieved from the World Bank (<https://data.worldbank.org/indicator/SP.RUR.TOTL.ZS>).

Data on the % of population living in rural areas over total population.

```{r}
rural_data <- read_xls("rural_pop.xls", sheet = 1, range = "A4:BL270")

# selecting only the relevant year
rural_data <- rural_data |> 
  select(`Country Name`, `Country Code`, `2019`) |> 
  clean_names() |> 
  rename("rural_pop_percentage" = "x2019")

# builidng a df with country names and codes for the EU-28
codelist <- countrycode::codelist |> 
  select(country.name.en, iso.name.en, un.name.en, cow.name, ecb, eurostat, iso2c, iso3c, eu28) |> 
  filter(!is.na(eu28)) 

rural_data <- rural_data |> 
  inner_join(select(codelist, iso3c), by = c("country_code" = "iso3c"))
str(rural_data)
```

### Same sex unions

Retrieved from Wikipedia (<https://en.wikipedia.org/wiki/Recognition_of_same-sex_unions_in_Europe>).

Table about status of same sex unions by country in Europe.

```{r}
# scraping the table
marriage_data <- read_html("https://en.wikipedia.org/wiki/Recognition_of_same-sex_unions_in_Europe") |>
  html_table() %>%
  .[[4]] |>
  select(Status, Country)

# cleaning the status column
marriage_data <- marriage_data |> 
  mutate(Status = str_remove(Status, "\\s*\\(.*|\\s*-.*")) |> 
  filter(!Status %in% c("Total", "Subtotal"))
unique(marriage_data$Status)

# cleaning the country column
marriage_data <- marriage_data |> 
  mutate(Country = str_replace_all(Country, c("\\*" = "", "â€ " = "", "\\[.*?\\]" = ""))) |> 
  mutate(Country = trimws(Country))
unique(marriage_data$Country)

# keeping only eu-28 countries 
marriage_data <- marriage_data |> 
  inner_join(select(codelist, cow.name), by = c("Country" = "cow.name"))
str(marriage_data)
```

This variable could be recoded as either ordinal, categorical (both factor) or logical.

The dataset has 32 observations instead of 28 (EU-28 countries).

```{r}
marriage_data |> 
  add_count(Country) |> 
  filter(n > 1)
```

According to this test, Croatia, Hungary, Latvia and Slovakia have two different types of status, so maybe we should cross-check with other sources?

Diego: the thing is that countries can at the same time have a constitutional ban on marriage and still have legally recognized civil unions. Thus maybe we should exclude this level from this variable as it is not exclusive. The lowest level would remain no recognition.

### Gender Equality Index

Developed by the European Institute for Gender Equality. Retrieved from <https://eige.europa.eu/gender-statistics/dgs/indicator/index__index_scores/datatable> for the year 2019.

```{r}
# cleaning the data
gequality_index <- read_xlsx("gender_equality_index_scores.xlsx", range = "A16:V44")
names(gequality_index) <- names(gequality_index) %>%
  janitor::make_clean_names() %>%
  gsub("_score$", "", .)
names(gequality_index)

gequality_index <- gequality_index |>  
  rename(country_name = geographic_region_sub_domain_scores)
str(gequality_index)
```

No UK in this datset (28 rows because it is present a row about EU as a whole)

### Economist's Democracy Index

```{r}
democracy_index <- read_xlsx("EIU_democracy_index.xlsx", sheet = 4)

# the ISO codes were lowercase which impedes the join
democracy_index$geo <- toupper(democracy_index$geo)

# filter for 2019 and EU28 countries
democracy_index <- democracy_index |> 
  filter(time == 2019) |> 
  inner_join((select(codelist, iso3c)), by = c("geo" = "iso3c"))

# clean var names
names(democracy_index) <- names(democracy_index) %>%
  janitor::make_clean_names() %>%
  gsub("_eiu$", "", .)

names(democracy_index)

democracy_index <- democracy_index |> 
  rename(country_code = geo,
         country_name = name,
         year = time)
```

In both of these tables (Gender Equality and Democracy indexes) there
are more indicators apart from the overall indexes, we have to decide if
we think they're useful or if we can discard some/all of them.

## Data cleaning

### Selecting relevant variables in the survey data

```{r}
data <- data_raw |> 
  select(serialid, # unique identifier
         isocntry, # 2 digit country code
         starts_with("d11"), # age which one should we keep?
         starts_with("q1"), # nationality of interviewee. options given: EU28+Other+DK
         d70, #life satisfaction
         starts_with("d71"), # interest in politics
         polintr, # political interest index (summarizes d71 questions)
         starts_with("sd1"), # friends that are minority groups
         starts_with("sd2"), # are you part of a minority
         sd3, # religion
         starts_with("qc1_"), # spread of discrimination in country
         starts_with("qc2_"), # experienced discrimination yourself
         qc3, # where discrimination took place
         starts_with("qc4"), # disadvantages during recruitment process
         starts_with("qc5"), # actions against discrimination
         starts_with("qc6"), # feelings about minority becoming elected official
         starts_with("qc7"), # feelings about efforts against discrimination
         starts_with("qc9"), # opinion about diversity in the workplace
         qc10, # how would you report discrimination
         starts_with("qc11"), # willingness to reveal sensitive information
         starts_with("qc12"), # feelings about colleagues being minority
         starts_with("qc13"), # feelings about kid being in a relationship with minority
         starts_with("qc15"), # opinions about lgbtqi 
         starts_with("qc17"), # information about minorities in school
         starts_with("qc18"), # feelings about public affection
         qc19, # target variable transgender
         qc20, # non-binary genders in documents
         d1, d1r1, d1r2, # political ideology
         starts_with("d7"), # marital status
         d10, # gender binary
         starts_with("d8"), # eduaction 
         starts_with("d15"), # occupation
         d25, # rural vs urban
         starts_with("d43"), # phones availiabilty
         d60, # financial stress (paying bills)
         starts_with("d62"), # internet use
         netuse, # internet index
         d63, # social class
         starts_with("d72"), # my voice counts
         d77, # convincing other people of your opinion 
         opls, # opinion leadership index
         # nuts, nutslvl, # region in which interview is carried out?
         # cntry_de useful?
         # starts_with("eu"), # groups by eu/eurozone memberships
         # starts_with("w"), # weights for what?
  )

paradata <- data_raw |> 
  select(serialid, # to match it with the other data
         p2, p3, p3r, p4, p5, # paradata)
  )
```

### Check overall data quality

```{r}
plot_intro(data)
```

All columns are numeric columns, the only one which is not is `isocntry`

```{r}
data |> 
  select(where(~ !is.numeric(.)))
```


```{r}
# Extracting all the full names of the columns
# They might be useful to rename the variables systematically
variable_names <- tibble(
  var_code = names(data),
  var_full_name = sapply(data, function(col) attr(col, "label")))
head(variable_names)
```

```{r}
# Trying to automatize the cleaning by extracting the labels and their respective names for each column
attr(data$d11r1, "labels")
names(attr(data$d11r1, "labels"))
tibble(name_labels = names(attr(data$d11r1, "labels")),
       labels = attr(data$d11r1, "labels"))

# Create a list of tibbles containing the labels and their associated name for each variable
list_label_tibbles <- 
  #Applies a function across all columns of a df and returns results as a list
  lapply(names(data), function(col_name) {
    labels <- attr(data[[col_name]], "labels")  # Extract labels
    name_labels <- names(labels)  # Extract label names
    # Create tibble with the extracted data only if labels exist
    if (!is.null(labels)) {
      tibble(name_labels = name_labels, labels = labels)} 
    else {NULL}  # Returns a NULL element for columns without labels
  })

# Giving to each element of the list as name the name of the variable
list_label_tibbles <- setNames(list_label_tibbles, names(data))

# For example
list_label_tibbles$d11r1
# Right column is what it appears in our data (as a number)
# Left column is the label that we must assign to that number when we factorize

# # Remove NULL elements (columns without labels)
# list_label_tibbles <- list_label_tibbles[!sapply(list_label_tibbles, is.null)]
```

### Start cleaning

```{r}
# Recoding together Germany East and West because we are running analysis at the country level
unique(data$isocntry)
data <- data |> 
  mutate(isocntry = case_when(
    isocntry %in% c("DE-W", "DE-E") ~ "DE",
    TRUE ~ isocntry))
# We might want to join the full name of the countries using the codelist df
```

```{r}
non_factor_variables <- c("serialid", "isocntry", "d11", 
                          names(data)[startsWith(names(data), "q1_")],
                          names(data)[startsWith(names(data), "sd2_")],
                          names(data)[startsWith(names(data), "qc2_")],
                          names(data)[startsWith(names(data), "qc4_")],
                          "d8", "opls")
factor_variables <- setdiff(names(data), non_factor_variables)

data <- data |> 
  mutate(across(all_of(factor_variables), labelled::to_factor))

data <- data |> 
  mutate(across(all_of(factor_variables), ~ fct_na_level_to_value(., extra_levels = "DK")))


# q1_ needs some other encoding ????
# check d15b
```


# Identify key socio-demogrpahic variables

From exploration of the codebook and dataframe:

*Target variable:* \* qc19 "Do you think that transgender persons should
be able to change their civil documents to match their inner gender
identity?"

Survey ID variables: - studyno1 to survey vars, all to be removed.

Respondent information -\> questions starting with "D" (D1-D77) -
political views, living situation, gender, education, occupation,
household characteristics, class

Key socioeconomic variables:

-   d1 - political ideology, left to right

-   d10 - Gender

-   d11 - Age exact

    -   Alternatives: d11r1 age recoded 4 cats, d11r2 age recoded 6
        cats, d11r3 age recoded 7 cats

-   d8 - Education, how old were you when you stopped full time
    education (Student = 00; No education = 01; refusal = 98; DK = 99

    -   d8r1 -\> 11 category recode

    -   d8r2 -\> 5 category recode s

-   d3 - religion

-   d25 - region lived in (1=rural, 2=small/medium town, 3=large town,
    4=DK)

-   d70 - life satisfaction: - 1 = very satisfied, 2= fairly, 3=not
    very, 4 = not at all, 5 = DK

-   D63 - class (working to higher, 1;5 then 6-9 no resp)

Uncertain variables, marital status (d7) /hh arrangement (d40)
/occupation (d15) / internet use (d60) Also the "sd" prefix variables..
these are about contact with different groups of discriminated people?

Paradata information -\> questions starting with "P" Paradata: -\>
P1-P10, date, time, length of interview, people present during
interview, respondent cooperation, location vars, interviewer number.

Select and rename these key variables:

```{r}
individuals_df <- data_raw |> 
  
  #use select function and rename all the in scope variables 
  select(
      uniqid, 
      isocntry,
      countryid,
      country_names,
        
    
      target_var = qc19,
      
    # socioeconomic variables for individuals 
      gender = d10,
      age = d11,
      age_4cat = d11r1,
      age_6cat = d11r2,
      age_7cat = d11r3,
      polit_ideology = d1,
      educ_5cat = d8r2, # all the education vars have low cutoffs 
      educ_11cat = d8r1,
      lifesat = d70,
      religion = sd3, 
      class = d63,
      occ_group_recode = d15a_r2, # the occupation vars are maybe not needed too
      financialstress = d60, #difficulty paying bills
      polintr, # no need to rename political interest var
      
    # paradata variables   
      int_date = p1,
      int_time = p2,
      int_length = p3r, #using recoded var instead of base p3 
      int_ppl_present = p4,
      int_resp_coop = p5,
      int_location = p6, # this may be a repeat of locality variable in survey. Useful maybe to consolidate data
      #p7 not useful, location, no data for p8-11
      
      #p13 is language of interview. Probably not useful? 
      )

```

Misc code for checking the sociodemographic vars (to be deleted)

```{r}
#check repeated cols
data_raw |> 
  select(starts_with("p13"))

# check labels
attr(data_raw$d15a_r2, "labels")
attr(data_raw$d7r, "labels")

#check values
summary(data_raw$p9)

```

## Remove unwanted variables

The approach above may be best.. but I did start this first by deleting
variables by process of elimination. Maybe good to justify some
decisions, but I'm not sure it matters either way.

-   we do need to decide on some of the attitudinal questions if they
    are relevant enough to include. I haven't looked at all enough in
    detail.

Variable groups I suggest removing: - gen1:gen6 -\> generation
variables, offer no more info than age - nationality variables -\> would
be easier and more accurate to join an overall % of immigration variable
if we want this data. - d71, -\> the three variables are summarised in
the `polintr` variable.

```{r}
id_vars <- c("studyno1", "studyno2", "doi", "version", "edition", "survey", "caseid", "uniqid", "serialid", "tnscntry", "country")
# remove ID vars
clean1 <- data_raw |> 
  select(-any_of(id_vars))

#remove nationality variable (q1). Later, if we decide we need an immigration variable, we can impute national level data.  
clean1 <- clean1 |> 
  select(-any_of(starts_with("q1")))

# remove generation variable, too similar to age
clean1 <- clean1 |> 
  select(-any_of(starts_with("gen")))

# remove additional paradata
# clean1 <- clean1 |> 
#   select(-any_of(starts_with("p7", "p13")))

```

To discuss re: cleaning. But I think also remove all these - qa set
(from qa1 to qa20) \* on trade, globalisation, eu business

-   qb set (from qb1 to qb9) \* on energy policy and EU priorities

Do we delete all these or are we expected to do some sort of
unsupervised learning or similar to consider their attitudes? I think
not.. There is questions about priority for business

Checking how many more variables it removes. It would be 159 removed.

```{r}
data_raw |> 
  select(any_of(starts_with(c("qa", "qb")))) |> 
  ncol()
```

Removing from my test data, this still has 409 variables though.

```{r}
clean1 <- clean1 |> 
  select(-any_of(starts_with(c("qa", "qb"))))

```

## Clean respondents personal data

I think some recoding or factorising may be necessary.

Note: There are lots of haven labelled columns.. it would be quite easy
to write a function to extract the label names to a new column? This
could be easier for when we want to investigate new variables?

```{r}

```

### Impute actual NA values

As these are inconsistent between each variable, I guess we need to
override and decide if we then impute the NA values.

Clean the education variable. Currently we have: d8 - Education, how old
were you when you stopped full time education (Student = 00; No
education = 01; refusal = 98; DK = 99 - d8r1 -\> 11 category recode -
d8r2 -\> 5 category recode

Clean the

```{r}
table(data_raw$d8, data_raw$d8r2)

# First, recode the d8 values that are given as NA or student/no education
clean1 |> 
  mutate(educ = if_else(d8 %in% c(0, 1, 98, 99), NA, d8))

# if d8 = 0, they are a current student. 

```

### Analysis of missing values.

Marga discussed the importance of understanding missing values. I think
this will be an important section where we also model what type of
people are more/less likely to not respond. It's a sort of robustness
check to see how much we can trust the models. Or if specific
demographics of people are less likely to respond, then we may trust it
less.

E.g. if men/religious people are less likely to respond, it could be an
issue. Ideally we would test the representativeness of our respondents
to the questions about transgender discrimination and the overall
populations.

```{r}
#plot_missing()
summary(data_raw$d11)
# returns nothing now because of NA values are all hard coded as mixed values e.g. some are 7, 98, 12. We probably need to standardise, section above maybe
  
```

## Descriptive data analysis and checks to start

Run comparisons by country to compare ages, gender distribution, Number
of respondents per country

```{r}
# number of respondents 
```

## Testing replication of the initial plot:

-   basic version only.

```{r}

```

-   we could also recreate without any NA values to see if it makes the
    plot just seem visually more even to start?

## Modelling

Some initial thoughts:

a)  modelling the target variables
    -   base model -\> using linear mixed model to analyse individual
        and country level differences

    -   model including paradata -\> see if these impacted outcomes too

b\. modelling differences in non-response?

-   I feel like Marga mentioned this? we would need to just create a
    dummy variable for NA response to the target variable question. This
    is our secondary model target variable. I guess this could be a
    classification model? for discussion but also more thoughts in my
    missing data note above...
